import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version',
};

interface NumberImage {
  number: number;
  imageUrl: string | null;
  pageUrl: string;
  cached?: boolean;
  error?: string;
  aiGenerated?: boolean;
  skipScrape?: boolean;
  autoGenerated?: boolean;
}

interface CacheEntry {
  number: number;
  storage_path: string;
}

// Rate limit configuration
const RATE_LIMITS = {
  perIp: {
    threshold: 20,
    windowMs: 5 * 60 * 1000,
    delayPerExcess: 10000,
  },
  global: {
    threshold: 100,
    windowMs: 60 * 1000,
    delayPerExcess: 5000,
  },
  maxDelay: 60000,
};

// ============= Smart Scraping Helpers =============

function isPowerOf2(n: number): boolean {
  return n > 0 && (n & (n - 1)) === 0;
}

function isPowerOf10(n: number): boolean {
  if (n < 10) return false;
  let num = n;
  while (num >= 10) {
    if (num % 10 !== 0) return false;
    num = num / 10;
  }
  return num === 1;
}

function hasRepeatingDigits(n: number): boolean {
  const str = n.toString();
  if (str.length < 2) return false;
  return str.split('').every(c => c === str[0]);
}

/**
 * Determines if a number is "special" enough to warrant a Firecrawl API call.
 * 
 * Rule A: Always try 1-100
 * Rule B: 101-1000 - only special numbers (multiples of 10/25/50, perfect squares, powers of 2, repeating digits)
 * Rule C: Above 1000 - only powers of 10 and named magnitudes
 */
function shouldScrape(num: number): boolean {
  // Rule A: Always try 1-100
  if (num <= 100) return true;
  
  // Rule B: 101-1000 - only special numbers
  if (num <= 1000) {
    // Multiples of 10, 25, 50
    if (num % 10 === 0) return true;
    if (num % 25 === 0) return true;
    if (num % 50 === 0) return true;
    
    // Perfect squares (121, 144, 169, 196, 225, 256, 289, 324, 361, 400...)
    const sqrt = Math.sqrt(num);
    if (Number.isInteger(sqrt)) return true;
    
    // Powers of 2 (128, 256, 512)
    if (isPowerOf2(num)) return true;
    
    // Repeating digits (111, 222, 333...)
    if (hasRepeatingDigits(num)) return true;
    
    return false;
  }
  
  // Rule C: Above 1000 - only very special
  // Powers of 10 (1000, 10000, 100000, 1000000...)
  if (isPowerOf10(num)) return true;
  
  // Named magnitudes that appear in educational material
  const namedMagnitudes = [
    1000, 10000, 100000, 1000000, 
    10000000, 100000000, 1000000000
  ];
  if (namedMagnitudes.includes(num)) return true;
  
  return false;
}

// ============= AI Generation Helper =============

async function generateWithAI(
  number: number, 
  supabase: any,
  clientIP: string = 'unknown'
): Promise<{ success: boolean; imageUrl?: string; error?: string }> {
  const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY');
  if (!OPENAI_API_KEY) {
    return { success: false, error: 'OPENAI_API_KEY is not configured' };
  }

  // Check AI generation rate limits (shared with generate-numberblock endpoint)
  const aiRateLimits = {
    perIp: { threshold: 10, windowMs: 10 * 60 * 1000, delayPerExcess: 15000 },
    global: { threshold: 50, windowMs: 10 * 60 * 1000, delayPerExcess: 10000 },
    maxDelay: 60000,
  };

  const now = new Date();
  const aiWindowStart = new Date(now.getTime() - aiRateLimits.perIp.windowMs);
  
  const { data: ipGenCalls } = await supabase
    .from('rate_limit_log')
    .select('api_calls_count')
    .eq('ip_address', clientIP)
    .eq('endpoint', 'generate-numberblock')
    .gte('created_at', aiWindowStart.toISOString());
  
  const ipGenTotal = ipGenCalls?.reduce((sum: number, r: { api_calls_count: number }) => sum + r.api_calls_count, 0) || 0;
  
  const { data: globalGenCalls } = await supabase
    .from('rate_limit_log')
    .select('api_calls_count')
    .eq('endpoint', 'generate-numberblock')
    .gte('created_at', aiWindowStart.toISOString());
  
  const globalGenTotal = globalGenCalls?.reduce((sum: number, r: { api_calls_count: number }) => sum + r.api_calls_count, 0) || 0;

  let genDelay = 0;
  if (ipGenTotal > aiRateLimits.perIp.threshold) {
    genDelay += (ipGenTotal - aiRateLimits.perIp.threshold) * aiRateLimits.perIp.delayPerExcess;
  }
  if (globalGenTotal > aiRateLimits.global.threshold) {
    genDelay += (globalGenTotal - aiRateLimits.global.threshold) * aiRateLimits.global.delayPerExcess;
  }
  genDelay = Math.min(genDelay, aiRateLimits.maxDelay);

  if (genDelay > 0) {
    console.log(`AI generation rate limited: IP=${clientIP}, ipTotal=${ipGenTotal}, globalTotal=${globalGenTotal}, delay=${genDelay}ms`);
    await new Promise(resolve => setTimeout(resolve, genDelay));
  }

  console.log(`Auto-generating AI image for Numberblock ${number} via OpenAI DALL-E 3`);

  try {
    const numberWord = numberToWordForAI(number);
    const structureGuide = getStructureGuide(number);
    const bodyColor = getNumberblockColor(number);
    
    const prompt = `You are drawing a Numberblocks character: a figure made of cube blocks from the BBC show. The TOTAL number of visible blocks must EXACTLY equal ${number}. One face on the front only. The number (Numberling) appears on top. Black and white line art only, for a coloring page.

CRITICAL: The NUMBER OF BLOCKS MUST BE EXACTLY ${number} (${numberWord}).
Count carefully: ${number} blocks total, no more, no less.

BLOCK LAYOUT (MUST be clearly visible and countable):
${structureGuide}

VERIFICATION INSTRUCTION:
After drawing, verify that the TOTAL number of blocks visible equals EXACTLY ${number}.
If you draw ${number <= 100 ? "each cube" : "the structural units"}, count them to ensure correctness.

CHARACTER DESIGN:
- The entire body is made of visible cube blocks in the arrangement above; each block is a small cube.
- Exactly ONE face on the front of the block structure: two simple eyes and a smile. No faces on side blocks.
- Draw the digit "${number.toLocaleString()}" on top of the character (above the blocks), bold and clear, like the show's Numberling.
- No arms or legs, OR very simple rounded limbs only (no stick figures).
- Use a single body color: ${bodyColor}. Draw as black outline only for coloring.

STRICT RULES:
- TOTAL block count MUST be ${number} - verify by counting
- Add NO extra blocks, NO missing blocks
- NO scenery, backgrounds, rainbows, or extra characters
- Number "${number.toLocaleString()}" must be on TOP of the blocks, not on the side or corner
- Only ONE face on the front, NO multiple faces
- Black outline ONLY - no shading, gradients, or detailed texture
- Static image - NO animation, NO GIF effects, NO motion

Result: one Numberblocks character, black and white line art, coloring page style, no background, EXACTLY ${number} blocks.`;

    const response = await fetch('https://api.openai.com/v1/images/generations', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'dall-e-3',
        prompt,
        n: 1,
        size: '1024x1024',
        response_format: 'b64_json',
        quality: 'standard',
      }),
    });

    if (!response.ok) {
      if (response.status === 429) {
        return { success: false, error: 'Rate limit exceeded' };
      }
      const errorText = await response.text();
      console.error('OpenAI DALL-E error:', response.status, errorText);
      return { success: false, error: 'Failed to generate image' };
    }

    const data = await response.json();
    const base64Data = data.data?.[0]?.b64_json;
    
    if (!base64Data) {
      return { success: false, error: 'No image generated' };
    }

    // DALL-E returns PNG images
    const imageType = 'png';
    
    const binaryString = atob(base64Data);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }

    const paddedNum = number.toString().padStart(3, '0');
    const storagePath = `ai-${paddedNum}.${imageType}`;
    
    const { error: uploadError } = await supabase.storage
      .from('numberblocks-images')
      .upload(storagePath, bytes, {
        contentType: `image/${imageType}`,
        upsert: true,
      });

    if (uploadError) {
      console.error('Storage upload error:', uploadError);
      return { success: false, error: 'Failed to save image' };
    }

    await supabase
      .from('numberblocks_cache')
      .upsert({
        number: number,
        storage_path: storagePath,
        original_url: 'ai-generated',
      }, { onConflict: 'number' });

    const { data: { publicUrl } } = supabase.storage
      .from('numberblocks-images')
      .getPublicUrl(storagePath);

    // Log AI generation call for rate limiting (shared endpoint with generate-numberblock)
    await logApiCalls(supabase, clientIP, 1, 'generate-numberblock');

    console.log(`Auto-generated AI image for ${number} saved at ${storagePath}`);
    
    return { success: true, imageUrl: publicUrl };
  } catch (error) {
    console.error('AI generation error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Canonical Numberblocks character colors (1-10 from the show); 11+ use single color.
function getNumberblockColor(num: number): string {
  const colors: Record<number, string> = {
    1: 'red', 2: 'orange', 3: 'yellow', 4: 'green', 5: 'blue',
    6: 'purple', 7: 'indigo', 8: 'pink', 9: 'teal', 10: 'light gray or white',
  };
  return colors[num] ?? 'single color';
}

// ============= Rate Limiting =============

function getClientIP(req: Request): string {
  return req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() 
    || req.headers.get('cf-connecting-ip') 
    || req.headers.get('x-real-ip')
    || 'unknown';
}

async function checkRateLimits(supabase: any, ip: string): Promise<{ delay: number; ipTotal: number; globalTotal: number }> {
  const now = new Date();
  
  const ipWindowStart = new Date(now.getTime() - RATE_LIMITS.perIp.windowMs);
  const { data: ipCalls } = await supabase
    .from('rate_limit_log')
    .select('api_calls_count')
    .eq('ip_address', ip)
    .gte('created_at', ipWindowStart.toISOString());
  
  const ipTotal = ipCalls?.reduce((sum: number, r: { api_calls_count: number }) => sum + r.api_calls_count, 0) || 0;
  
  const globalWindowStart = new Date(now.getTime() - RATE_LIMITS.global.windowMs);
  const { data: globalCalls } = await supabase
    .from('rate_limit_log')
    .select('api_calls_count')
    .gte('created_at', globalWindowStart.toISOString());
  
  const globalTotal = globalCalls?.reduce((sum: number, r: { api_calls_count: number }) => sum + r.api_calls_count, 0) || 0;
  
  let delay = 0;
  if (ipTotal > RATE_LIMITS.perIp.threshold) {
    delay += (ipTotal - RATE_LIMITS.perIp.threshold) * RATE_LIMITS.perIp.delayPerExcess;
  }
  if (globalTotal > RATE_LIMITS.global.threshold) {
    delay += (globalTotal - RATE_LIMITS.global.threshold) * RATE_LIMITS.global.delayPerExcess;
  }
  
  return { 
    delay: Math.min(delay, RATE_LIMITS.maxDelay),
    ipTotal,
    globalTotal
  };
}

async function logApiCalls(supabase: any, ip: string, count: number, endpoint: string = 'scrape-numberblocks'): Promise<void> {
  if (count <= 0) return;
  
  const { error } = await supabase.from('rate_limit_log').insert({
    ip_address: ip,
    endpoint,
    api_calls_count: count,
  });
  
  if (error) {
    console.error('Failed to log API calls:', error);
  }
}

async function cleanupOldRateLimitLogs(supabase: any): Promise<void> {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
  
  const { error } = await supabase
    .from('rate_limit_log')
    .delete()
    .lt('created_at', oneHourAgo.toISOString());
  
  if (error) {
    console.error('Failed to cleanup old rate limit logs:', error);
  }
}

// ============= Main Handler =============

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const apiKey = Deno.env.get('FIRECRAWL_API_KEY');
    if (!apiKey) {
      console.error('FIRECRAWL_API_KEY not configured');
      return new Response(
        JSON.stringify({ success: false, error: 'Firecrawl connector not configured' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const clientIP = getClientIP(req);
    const body = await req.json();
    const startNumber = body.startNumber ?? 1;
    const endNumber = body.endNumber ?? 20;
    const isSingleNumber = body.isSingleNumber ?? (startNumber === endNumber);

    // Input validation
    const MAX_RANGE = 50;
    
    if (typeof startNumber !== 'number' || typeof endNumber !== 'number' ||
        !Number.isFinite(startNumber) || !Number.isFinite(endNumber)) {
      return new Response(
        JSON.stringify({ success: false, error: 'Start and end numbers must be valid numbers' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!Number.isInteger(startNumber) || !Number.isInteger(endNumber)) {
      return new Response(
        JSON.stringify({ success: false, error: 'Numbers must be whole integers' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (startNumber < 0 || endNumber < 0) {
      return new Response(
        JSON.stringify({ success: false, error: 'Numbers must be 0 or greater' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (startNumber > endNumber) {
      return new Response(
        JSON.stringify({ success: false, error: 'Start number must be less than or equal to end number' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (endNumber - startNumber + 1 > MAX_RANGE) {
      return new Response(
        JSON.stringify({ success: false, error: `Maximum range is ${MAX_RANGE} numbers per request` }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    console.log(`Processing Numberblocks images from ${startNumber} to ${endNumber} (IP: ${clientIP}, singleNumber: ${isSingleNumber})`);
    
    // Check which numbers are already cached
    const { data: cachedEntries } = await supabase
      .from('numberblocks_cache')
      .select('number, storage_path')
      .gte('number', startNumber)
      .lte('number', endNumber);
    
    const cachedMap = new Map<number, string>();
    if (cachedEntries) {
      for (const entry of cachedEntries) {
        cachedMap.set(entry.number, entry.storage_path);
      }
    }
    
    console.log(`Found ${cachedMap.size} cached images`);
    
    const results: NumberImage[] = [];
    const numbersToScrape: number[] = [];
    
    // Build list of numbers to scrape vs return from cache vs skip
    for (let num = startNumber; num <= endNumber; num++) {
      if (cachedMap.has(num)) {
        // Return from cache
        const storagePath = cachedMap.get(num)!;
        const { data: { publicUrl } } = supabase.storage
          .from('numberblocks-images')
          .getPublicUrl(storagePath);
        
        const isAIGenerated = storagePath.startsWith('ai-');
        
        results.push({
          number: num,
          imageUrl: publicUrl,
          pageUrl: `https://numberblocks.fandom.com/wiki/${numberToWord(num)}`,
          cached: true,
          aiGenerated: isAIGenerated,
        });
      } else if (!shouldScrape(num)) {
        // Skip scraping for non-special numbers
        console.log(`Skipping scrape for ${num} (not a special number)`);
        results.push({
          number: num,
          imageUrl: null,
          pageUrl: `https://numberblocks.fandom.com/wiki/${numberToWord(num)}`,
          error: 'Not expected to have wiki image',
          skipScrape: true,
        });
      } else {
        numbersToScrape.push(num);
      }
    }
    
    console.log(`Need to scrape ${numbersToScrape.length} new images (${results.filter(r => r.skipScrape).length} skipped as non-special)`);

    let wasThrottled = false;
    let appliedDelay = 0;
    
    // Only check rate limits if we need to make API calls
    if (numbersToScrape.length > 0) {
      const { delay, ipTotal, globalTotal } = await checkRateLimits(supabase, clientIP);
      
      if (delay > 0) {
        wasThrottled = true;
        appliedDelay = delay;
        console.log(`Rate limiting: IP=${clientIP}, ipTotal=${ipTotal}, globalTotal=${globalTotal}, delay=${delay}ms`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
      
      const batchSize = 5;
      let apiCallsCount = 0;
      
      for (let i = 0; i < numbersToScrape.length; i += batchSize) {
        const batch = numbersToScrape.slice(i, i + batchSize);
        const batchPromises = batch.map(num => scrapeAndCacheNumber(num, apiKey, supabase, supabaseUrl));
        
        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);
        apiCallsCount += batch.length;
        
        if (i + batchSize < numbersToScrape.length) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      
      await logApiCalls(supabase, clientIP, apiCallsCount);
      
      if (Math.random() < 0.01) {
        cleanupOldRateLimitLogs(supabase).catch(console.error);
      }
    }
    
    // Auto-generate for single number if no image found
    if (isSingleNumber) {
      const singleResult = results.find(r => r.number === startNumber);
      if (singleResult && !singleResult.imageUrl && !singleResult.cached) {
        console.log(`Auto-generating AI image for single number ${startNumber}`);
        const generated = await generateWithAI(startNumber, supabase, clientIP);
        if (generated.success && generated.imageUrl) {
          singleResult.imageUrl = generated.imageUrl;
          singleResult.aiGenerated = true;
          singleResult.autoGenerated = true;
          singleResult.error = undefined;
          singleResult.skipScrape = undefined;
        }
      }
    }
    
    // Sort results by number
    results.sort((a, b) => a.number - b.number);

    const successCount = results.filter(r => r.imageUrl).length;
    const cachedCount = results.filter(r => r.cached).length;
    const skippedCount = results.filter(r => r.skipScrape).length;
    const autoGeneratedCount = results.filter(r => r.autoGenerated).length;
    console.log(`Returning ${results.length} images (${cachedCount} cached, ${successCount - cachedCount} newly scraped, ${skippedCount} skipped, ${autoGeneratedCount} auto-generated)`);

    const responseHeaders = { 
      ...corsHeaders, 
      'Content-Type': 'application/json',
      'X-Rate-Limited': wasThrottled ? 'true' : 'false',
      'X-Rate-Limit-Delay': appliedDelay.toString(),
    };

    return new Response(
      JSON.stringify({ 
        success: true, 
        data: results,
        rateLimited: wasThrottled,
        delayApplied: appliedDelay,
      }),
      { headers: responseHeaders }
    );
  } catch (error) {
    console.error('Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Failed to process';
    return new Response(
      JSON.stringify({ success: false, error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

async function scrapeAndCacheNumber(num: number, apiKey: string, supabase: any, supabaseUrl: string): Promise<NumberImage> {
  const numberWord = numberToWord(num);
  const pageUrl = `https://numberblocks.fandom.com/wiki/${encodeURIComponent(numberWord)}`;
  
  console.log(`Scraping: ${pageUrl}`);
  
  try {
    const response = await fetch('https://api.firecrawl.dev/v1/scrape', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        url: pageUrl,
        formats: ['html', 'links'],
        onlyMainContent: false,
      }),
    });

    const data = await response.json();

    if (!response.ok) {
      console.error(`Firecrawl error for ${num}:`, data);
      return { number: num, imageUrl: null, pageUrl, error: data.error || 'Request failed' };
    }

    const html = data.data?.html || data.html || '';
    const originalImageUrl = extractInfoboxImage(html, num);
    
    if (!originalImageUrl) {
      return { number: num, imageUrl: null, pageUrl, error: 'No image found' };
    }
    
    const imageResponse = await fetch(originalImageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Referer': 'https://numberblocks.fandom.com/',
      },
    });
    
    if (!imageResponse.ok) {
      console.error(`Failed to download image for ${num}: ${imageResponse.status}`);
      return { number: num, imageUrl: originalImageUrl, pageUrl };
    }
    
    const contentType = imageResponse.headers.get('content-type') || 'image/png';
    const imageData = await imageResponse.arrayBuffer();
    
    let extension = 'png';
    if (contentType.includes('jpeg') || contentType.includes('jpg')) extension = 'jpg';
    else if (contentType.includes('gif')) extension = 'gif';
    else if (contentType.includes('webp')) extension = 'webp';
    
    const paddedNum = num.toString().padStart(3, '0');
    const storagePath = `${paddedNum}.${extension}`;
    
    const { error: uploadError } = await supabase.storage
      .from('numberblocks-images')
      .upload(storagePath, imageData, {
        contentType,
        upsert: true,
      });
    
    if (uploadError) {
      console.error(`Failed to cache image ${num}:`, uploadError);
      return { number: num, imageUrl: originalImageUrl, pageUrl };
    }
    
    await supabase
      .from('numberblocks_cache')
      .upsert({
        number: num,
        storage_path: storagePath,
        original_url: originalImageUrl,
      }, { onConflict: 'number' });
    
    const { data: { publicUrl } } = supabase.storage
      .from('numberblocks-images')
      .getPublicUrl(storagePath);
    
    console.log(`Cached image ${num} at ${storagePath}`);
    
    return { number: num, imageUrl: publicUrl, pageUrl, cached: true };
  } catch (error) {
    console.error(`Error processing ${num}:`, error);
    return { 
      number: num, 
      imageUrl: null, 
      pageUrl, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
}

function isValidCharacterImage(imageUrl: string): boolean {
  const invalidPatterns = [
    /placeholder/i,
    /icon/i,
    /favicon/i,
    /logo/i,
    /banner/i,
    /Site-logo/i,
    /Wiki-wordmark/i,
    /Community-header/i,
    /avatar/i,
    /badge/i,
    /button/i,
    /sprite/i,
    /Blocks_Universe/i,
    /BLOCKS.*UNIVERSE/i,
    /community/i,
    /wiki.*wordmark/i,
  ];
  
  for (const pattern of invalidPatterns) {
    if (pattern.test(imageUrl)) {
      return false;
    }
  }
  
  if (!imageUrl.includes('static.wikia.nocookie.net/numberblocks/images')) {
    return false;
  }
  
  return true;
}

function extractInfoboxImage(html: string, num: number): string | null {
  const numStr = num.toString();
  const numberName = numberToWord(num).toLowerCase().replace(/[_-]/g, '');
  
  const allImgMatches = [...html.matchAll(/<img[^>]*src="([^"]+)"[^>]*>/gi)];
  
  // Priority 1: Look for images with the exact number in the URL
  for (const match of allImgMatches) {
    let imageUrl = match[1];
    
    if (!isValidCharacterImage(imageUrl)) {
      continue;
    }
    
    const urlPath = imageUrl.split('/').pop()?.split('?')[0] || '';
    const urlLower = urlPath.toLowerCase();
    
    const numWithCommas = num.toLocaleString();
    if (urlLower.includes(numStr) || urlLower.includes(numWithCommas.replace(/,/g, ''))) {
      imageUrl = imageUrl.replace(/\/revision\/latest\/scale-to-width-down\/\d+/, '/revision/latest');
      imageUrl = imageUrl.replace(/\/revision\/latest\/smart\/width\/\d+\/height\/\d+/, '/revision/latest');
      return imageUrl;
    }
  }
  
  // Priority 2: For small numbers, try the infobox patterns
  if (num <= 1000) {
    const infoboxPatterns = [
      /class="pi-image[^"]*"[^>]*>.*?<img[^>]*src="([^"]+)"[^>]*>/is,
      /<aside[^>]*class="[^"]*infobox[^"]*"[^>]*>.*?<img[^>]*src="([^"]+)"[^>]*>/is,
    ];

    for (const pattern of infoboxPatterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        let imageUrl = match[1];
        imageUrl = imageUrl.replace(/\/revision\/latest\/scale-to-width-down\/\d+/, '/revision/latest');
        imageUrl = imageUrl.replace(/\/revision\/latest\/smart\/width\/\d+\/height\/\d+/, '/revision/latest');
        
        if (isValidCharacterImage(imageUrl)) {
          return imageUrl;
        }
      }
    }
    
    // Priority 3: Fallback for small numbers - check if filename contains number word
    for (const match of allImgMatches) {
      let imageUrl = match[1];
      
      if (!isValidCharacterImage(imageUrl)) {
        continue;
      }
      
      const urlLower = imageUrl.toLowerCase();
      if (urlLower.includes(numberName)) {
        imageUrl = imageUrl.replace(/\/revision\/latest\/scale-to-width-down\/\d+/, '/revision/latest');
        imageUrl = imageUrl.replace(/\/revision\/latest\/smart\/width\/\d+\/height\/\d+/, '/revision/latest');
        return imageUrl;
      }
    }
  }

  return null;
}

function numberToWord(num: number): string {
  const ones = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine',
                'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 
                'Seventeen', 'Eighteen', 'Nineteen'];
  const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'];
  
  if (num === 0) return 'Zero';
  if (num < 20) return ones[num];
  if (num < 100) {
    const ten = Math.floor(num / 10);
    const one = num % 10;
    return tens[ten] + (one > 0 ? '-' + ones[one].toLowerCase() : '');
  }
  if (num === 100) return 'One_Hundred';
  if (num > 100 && num < 1000) {
    const hundred = Math.floor(num / 100);
    const remainder = num % 100;
    if (remainder === 0) {
      return ones[hundred] + '_Hundred';
    }
    return ones[hundred] + '_Hundred_' + numberToWord(remainder).replace('-', '_');
  }
  if (num === 1000) return 'One_Thousand';
  
  return num.toString();
}

// Version for AI prompts (readable format)
function numberToWordForAI(num: number): string {
  const ones = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine',
                'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 
                'Seventeen', 'Eighteen', 'Nineteen'];
  const tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'];
  
  if (num === 0) return 'Zero';
  if (num < 20) return ones[num];
  if (num < 100) {
    const ten = Math.floor(num / 10);
    const one = num % 10;
    return tens[ten] + (one > 0 ? '-' + ones[one].toLowerCase() : '');
  }
  if (num === 100) return 'One Hundred';
  if (num > 100 && num < 1000) {
    const hundred = Math.floor(num / 100);
    const remainder = num % 100;
    if (remainder === 0) {
      return ones[hundred] + ' Hundred';
    }
    return ones[hundred] + ' Hundred ' + numberToWordForAI(remainder);
  }
  if (num === 1000) return 'One Thousand';
  if (num >= 1000 && num < 1000000) {
    const thousands = Math.floor(num / 1000);
    const remainder = num % 1000;
    if (remainder === 0) {
      return numberToWordForAI(thousands) + ' Thousand';
    }
    return numberToWordForAI(thousands) + ' Thousand ' + numberToWordForAI(remainder);
  }
  if (num >= 1000000) {
    const millions = Math.floor(num / 1000000);
    const remainder = num % 1000000;
    if (remainder === 0) {
      return numberToWordForAI(millions) + ' Million';
    }
    return numberToWordForAI(millions) + ' Million ' + numberToWordForAI(remainder);
  }
  
  return num.toLocaleString();
}

function getStructureGuide(num: number): string {
  if (num <= 9) {
    return `- Build as a simple stack or rectangle of exactly ${num} visible, countable cubes
- Each individual cube should be clearly visible and countable
- Arrange in a compact shape (e.g., ${getSmallNumberArrangement(num)})
- The child should be able to count every single block`;
  }
  
  if (num === 10) {
    return `- Show as a clean rectangle of 10 blocks (2 columns of 5, or 1 row of 10)
- Ten is the first "grouped unit" - make it look like a building block itself
- All 10 cubes should be visible but arranged as a unified shape`;
  }
  
  if (num <= 99) {
    const tensNum = Math.floor(num / 10);
    const onesNum = num % 10;
    const onesText = onesNum > 0 ? ` with ${onesNum} extra single block${onesNum > 1 ? 's' : ''} attached on the side or top` : '';
    return `- Build from ${tensNum} groups of ten${onesText}
- The tens form the main rectangular body
- Extra ones attach clearly and separately
- The viewer should "see" addition: ${tensNum}×10 + ${onesNum} = ${num}
- All blocks should still be individually visible`;
  }
  
  if (num === 100) {
    return `- Show as a large 10×10 square grid (100 blocks total)
- This is the first number where counting is impractical
- The structure should signal "hundred" through its grid pattern
- Individual cubes can be implied but the 10×10 structure must be clear`;
  }
  
  if (num <= 999) {
    const hundreds = Math.floor(num / 100);
    const remainder = num % 100;
    const remainderText = remainder > 0 ? ` plus visible extra blocks for the remaining ${remainder}` : '';
    return `- Show as ${hundreds} stacked or side-by-side 10×10 hundred-slabs${remainderText}
- Each hundred-slab keeps its 10×10 identity
- Structure is architectural - the count is implied by the pattern
- Think of it as ${hundreds} "hundred-blocks" combined`;
  }
  
  if (num <= 9999) {
    const thousands = Math.floor(num / 1000);
    const remainder = num % 1000;
    return `- Conceptualize as ${thousands} "thousand-blocks" (each is a cube of 10 hundred-slabs)
- Individual cubes cannot all be drawn - use structural representation
- Show the magnitude through HEIGHT and SCALE, not individual blocks
- ${remainder > 0 ? `Include visual indication of the extra ${remainder}` : 'Clean thousand-block structure'}
- Use mega-blocks arranged in clean grids and balanced rectangles`;
  }
  
  if (num <= 999999) {
    const mainUnit = Math.floor(num / 1000);
    return `- SYMBOLIC STRUCTURE: Impossible to show every cube
- Represent as ${mainUnit.toLocaleString()} thousand-blocks in a massive grid/tower
- Use repeating patterns of known shapes (tens, hundreds) to signal scale
- WIDTH and HEIGHT show magnitude, not literal cube count
- Think architectural monument, not countable blocks
- Clear visual hierarchy: the number is understood by STRUCTURE, not detail`;
  }
  
  return `- PURE STRUCTURE AND SCALE representation
- Show as a monumental tower or massive cube made of implied thousand-layers
- Individual blocks are completely abstracted into mega-structures
- Use labels, perspective, and sheer size to convey magnitude
- The character should feel MASSIVE and architectural
- Think skyscraper or mountain-sized, with structure implying the count`;
}

function getSmallNumberArrangement(num: number): string {
  switch (num) {
    case 1: return '1 single cube';
    case 2: return '2 cubes stacked vertically or side-by-side';
    case 3: return '3 cubes in a triangle or row';
    case 4: return '2×2 square';
    case 5: return '5 cubes in a plus shape or row';
    case 6: return '2×3 rectangle';
    case 7: return '2×3 + 1 on top';
    case 8: return '2×4 rectangle or 2×2×2 cube';
    case 9: return '3×3 square';
    default: return `${num} cubes arranged compactly`;
  }
}
